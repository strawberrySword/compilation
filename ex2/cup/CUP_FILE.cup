/*************/
/* IMPORT(S) */
/*************/
import java_cup.runtime.*;
import java.io.*;
import java.io.PrintWriter;
import AST.*;

parser code 
{:
	public Lexer lexer;
	public PrintWriter writer;

	public Parser(Lexer lexer, PrintWriter writer)
	{
		super(lexer);
		this.lexer = lexer;
		this.writer = writer;
	}
	public void report_error(String message, Object info)
	{
		
		writer.write("Error");
		writer.close();
		System.exit(0);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	s = lexer.next_token();
	return s; 
:};

/*************/
/* TERMINALS */
/*************/
terminal IF;
terminal EQ;
terminal DOT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal WHILE;
terminal DIVIDE;
terminal LPAREN;
terminal RPAREN;
terminal LBRACK;
terminal RBRACK;
terminal LBRACE;
terminal RBRACE;
terminal CLASS;
terminal NIL;
terminal ARRAY;
terminal TYPE_INT;
terminal TYPE_VOID;
terminal EXTENDS;
terminal RETURN;
terminal NEW;
terminal COMMA;
terminal SEMICOLON;
terminal ASSIGN;
terminal LT;
terminal GT;
terminal TYPE_STRING;

/*************/
/* TERMINALS */
/*************/
terminal Integer INT;
terminal String ID;
terminal String STRING;

/*****************/
/* NON TERMINALS */
/*****************/
// non terminal AST_EXP exp;
// non terminal AST_VAR var;
// non terminal AST_STMT stmt;
// non terminal AST_STMT_LIST stmtList;
non terminal program;
non terminal dec;
non terminal type;
non terminal varDec;
non terminal funcDec;
non terminal commaTypeIdStar;
non terminal classDec;
non terminal cField;
non terminal cFieldPlus;
non terminal arrayTypedef;
non terminal exp;
non terminal commaExpStar;
non terminal var;
non terminal stmt;
non terminal stmtPlus;
non terminal newExp;
non terminal BINOP;
non terminal commaExpPlus;
non terminal commaTypeIdPlus;


/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence nonassoc ASSIGN;
precedence left EQ;
precedence left LT;
precedence left GT;
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;
precedence left DIVIDE;
precedence nonassoc LBRACK;
precedence nonassoc LBRACE;
precedence left DOT;

/************************/
/* START WITH: stmtList or Program!*/
/************************/
start with program;

/********************/
/* DERIVATION RULES */
/********************/

program		::=		dec:s program:l 	{:RESULT = new AST_DEC_LIST(s,l):}
					| dec:s				{:RESULT = new AST_DEC_LIST(s, null):}
					;

dec			::=		varDec:dec 			{:RESULT = new AST_DEC(dec):}
					| funcDec:dec		{:RESULT = new AST_DEC(dec):}
					| classDec:dec 		{:RESULT = new AST_DEC(dec):}
					| arrayTypedef:dec	{:RESULT = new AST_DEC(dec):}
					;

type		::= 	TYPE_INT:t 		
					| TYPE_STRING:t 
					| TYPE_VOID:t 	
					| ID:t			
					;

varDec 		::=		type:t ID:name ASSIGN exp:val SEMICOLON 		{:RESULT = new AST_VAR_DEC(t,name,val,null):}
					| type:t ID:name SEMICOLON						{:RESULT = new AST_VAR_DEC(t,name):}
					| type:t ID:name ASSIGN newExp:val SEMICOLON	{:RESULT = new AST_VAR_DEC(t,name,null,val):}
					;

funcDec		::= 	type:retType ID:funcName LPAREN type:type1 ID:arg1 commaTypeIdStar:args RPAREN LBRACE stmtPlus:statements RBRACE	{:RESULT = new AST_FUNC_DEC(retType, funcName, type1, arg1, args, statements):}
					| type ID LPAREN RPAREN LBRACE stmtPlus RBRACE	{:RESULT = new AST_FUNC_DEC(retType, funcName, statements):}
					;

commaTypeIdPlus ::= COMMA type ID commaTypeIdPlus 
					| COMMA type ID 
					;

commaTypeIdStar	::=	commaTypeIdPlus
					| 
					;

classDec	::=		CLASS ID:cName EXTENDS ID:parentName LBRACE cFieldPlus:fields RBRACE	{:RESULT = new AST_CLASS_DEC(cName, parentName, fields):}
					| CLASS ID:cName LBRACE cFieldPlus:fields RBRACE				{:RESULT = new AST_CLASS_DEC(cName, fields):}
					;

cField		::=		varDec {:RESULT = new AST_CLASS_FIELD():}
					| funcDec
					;

cFieldPlus	::=		cField cFieldPlus
					| cField
					;

arrayTypedef	::=	ARRAY ID EQ type LBRACK RBRACK SEMICOLON
					;

exp			::=		var 
					| LPAREN exp RPAREN
					| exp BINOP exp
					| var DOT ID LPAREN exp commaExpStar RPAREN
					| var DOT ID LPAREN RPAREN
					| ID LPAREN exp commaExpStar RPAREN
					| ID LPAREN RPAREN
					| MINUS INT 
					| INT 
					| NIL 
					| STRING 
					;

commaExpPlus ::=	COMMA exp | COMMA exp commaExpPlus;

commaExpStar ::= 	commaExpPlus
					| 
					;

var			::=		ID:name 						{:	RESULT = new AST_VAR_SIMPLE(name):} 
					| var:v DOT ID:fieldName		{:	RESULT = new AST_VAR_FIELD(v, fieldName)	:}	 
					| var LBRACK exp RBRACK			{:	RESULT = new AST_VAR_SUBSCRIPT(v,e)	:}
					;
					
stmt		::=		varDec
					| var:v ASSIGN exp:e SEMICOLON					{:	RESULT = new AST_STMT_ASSIGN(v,e):}
					| var:v ASSIGN newExp:e SEMICOLON				{:	RESULT = new AST_STMT_ASSIGN_NEW(v,e):}
					| RETURN exp:e SEMICOLON						{:	RESULT = new AST_STMT_RETURN(e):}
					| RETURN SEMICOLON								{:	RESULT = new AST_STMT_RETURN(null):}
					| IF LPAREN exp:cond RPAREN LBRACE stmtPlus:body RBRACE		{:	RESULT = new AST_STMT_IF(cond, body):}
					| WHILE LPAREN exp:cond RPAREN LBRACE stmtPlus:body RBRACE	{:	RESULT = new AST_STMT_WHILE(cond, body):}
					| var:v DOT ID:func LPAREN exp:arg1 commaExpStar:args RPAREN SEMICOLON		{:	RESULT = new AST_STMT_FUNCTION_CALL_FIELD(v, func, arg1, args):}
					| ID:func LPAREN exp:arg1 commaExpStar:args RPAREN SEMICOLON 	{:	RESULT = new AST_STMT_FUNCTION_CALL(func, arg1, args):}
					| var:v DOT ID:func LPAREN RPAREN SEMICOLON 	{:	RESULT = new AST_STMT_FUNCTION_CALL_FIELD(v, func):}
					| ID:func LPAREN RPAREN SEMICOLON				{:	RESULT = new AST_STMT_FUNCTION_CALL(func):}
					;

stmtPlus	::=		stmt:s	stmtPlus:l 		{: 	RESULT = new AST_STMT_LIST(s,l) :}
					| stmt 					{:	RESULT = new AST_STMT_LIST(s, null):}
					;

newExp 		::= 	NEW type: 
					| NEW type LBRACK exp RBRACK 
					;

BINOP 		::= 	PLUS:op {:RESULT = new AST_BINOP(op):}
					| MINUS:op	{:RESULT = new AST_BINOP(op):} 
					| TIMES:op	{:RESULT = new AST_BINOP(op):}
					| DIVIDE:op	{:RESULT = new AST_BINOP(op):}
					| LT:op	{:RESULT = new AST_BINOP(op):}
					| GT:op	{:RESULT = new AST_BINOP(op):}
					| EQ:op	{:RESULT = new AST_BINOP(op):}
					;


